<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />

    <title>Jbinarytree by mmontuori</title>
  </head>

  <body>

    <header>
      <div class="container">
        <h1>Jbinarytree</h1>
        <h2>Java Binary Search Tree Implementation</h2>

        <section id="downloads">
          <a href="https://github.com/mmontuori/jbinarytree/zipball/master" class="btn">Download as .zip</a>
          <a href="https://github.com/mmontuori/jbinarytree/tarball/master" class="btn">Download as .tar.gz</a>
          <a href="https://github.com/mmontuori/jbinarytree" class="btn btn-github"><span class="icon"></span>View on GitHub</a>
        </section>
      </div>
    </header>

    <div class="container">
      <section id="main_content">
        <h1>
<a name="jbinarytree" class="anchor" href="#jbinarytree"><span class="octicon octicon-link"></span></a><em>JBinaryTree</em>
</h1>

<p><em>Description: JBinaryTree is an implementation of a binary search tree in Java. The project started as an academic excercise, but soon, it was transformed to a full object oriented implementation for any developer wanting to use search binary trees. JBinaryTree supports the most common traversal algorithmns plus a reverse in order trasversal not present in the specifications, but very useful for programmers wanting to reverse traverse the tree.</em></p>

<p><em>Suggestions are always welcomed.</em></p>

<h2>
<a name="documentation" class="anchor" href="#documentation"><span class="octicon octicon-link"></span></a>Documentation</h2>

<p>All documentation is in javadoc format <a href="http://mmontuori.github.io/jbinarytree/javadoc/">http://mmontuori.github.io/jbinarytree/javadoc/</a></p>

<h2>
<a name="project-setup" class="anchor" href="#project-setup"><span class="octicon octicon-link"></span></a>Project Setup</h2>

<p><em>Using JBinaryTree is simple. A sample implementaion on an Integer as key and String as value is privided as a template. Following is a snippet implementation:</em></p>

<pre><code>public class IntStringBinaryTree extends BinaryTree&lt;Integer, String&gt; {

    public IntStringBinaryTree(boolean debug) {
        super(debug);
    }

    @Override
    public int compare(Node&lt;Integer, String&gt; a, Node&lt;Integer, String&gt; b) {
        if ( a.key.intValue() &lt; b.key.intValue() ) {
            return -1;
        } else if ( a.key.intValue() == b.key.intValue() ){
            return 0;
        } else {
            return 1;
        }
    }

    @Override
    public void orderedNode(Node&lt;Integer, String&gt; orderedNode) {
        Integer key = orderedNode.key;
        System.out.println("ordered node key: " + key.intValue());
    }

}
</code></pre>

<p>This is all it takes to create a Binary Search Tree implementiation of Integer as key, and String as value. A sample usage of a class implementing 100 random numbers in the binary tree, find a record, and remove a record is:</p>

<pre><code>import java.util.Random;

import com.mmontuori.binarytree.*;

public class TestBinTree {

    private static final int SIZE = 100;

    public static void main(String[] args) {
        BinaryTree&lt;Integer, String&gt; testTree = new IntStringBinaryTree();
        Random random = new Random();
        int toSearch = 0;
        for ( int i=0; i&lt;SIZE; ++i) {
            int rnd = random.nextInt(10000);
            Integer key = new Integer(rnd);
            String value = String.valueOf(rnd);
            Node&lt;Integer, String&gt; node = new Node&lt;Integer,String&gt;(key, value);
            System.out.println("adding node: " + rnd);
            testTree.addNode(node);
            if ( SIZE/2 == i ) {
                toSearch = rnd;
                System.out.println("record to search and remove: " + toSearch);
            }
        }
        System.out.println("tree size: " + testTree.getSize());
        System.out.println("tree right size: " + testTree.getRightSize());
        System.out.println("tree left size: " + testTree.getLeftSize());
        testTree.traverseInOrder(testTree.getRoot());
        Integer key = new Integer(toSearch);
        Node&lt;Integer,String&gt; node = testTree.findNode(key);
        System.out.println("node found: " + node.key.intValue());
        testTree.removeNode(toSearch);
        testTree.traverseInOrder(testTree.getRoot());
        System.out.println("tree size: " + testTree.getSize());
        System.out.println("tree right size: " + testTree.getRightSize());
        System.out.println("tree left size: " + testTree.getLeftSize());
    }

}
</code></pre>

<h2>
<a name="deploying" class="anchor" href="#deploying"><span class="octicon octicon-link"></span></a>Deploying</h2>

<p><em>Just add jbinarytree.jar to your CLASSPATH and use it.</em></p>

<h2>
<a name="license" class="anchor" href="#license"><span class="octicon octicon-link"></span></a>License</h2>

<p>JBinaryTree is release under the GPLv2 license.</p>
      </section>
    </div>

    
  </body>
</html>