{"name":"Jbinarytree","tagline":"Java Binary Search Tree Implementation","body":"# _JBinaryTree_\r\n\r\n_Description: JBinaryTree is an implementation of a binary search tree in Java. The project started as an academic excercise, but soon, it was transformed to a full object oriented implementation for any developer wanting to use search binary trees. JBinaryTree supports the most common traversal algorithmns plus a reverse in order trasversal not present in the specifications, but very useful for programmers wanting to reverse traverse the tree._\r\n\r\n_Suggestions are always welcomed._\r\n\r\n## Documentation\r\n\r\nAll documentation is in javadoc format http://mmontuori.github.io/jbinarytree/javadoc/\r\n\r\n## Download\r\n\r\nhttp://mmontuori.github.io/jbinarytree/jar/jbinarytree.jar\r\n\r\n## Project Setup\r\n\r\n_Using JBinaryTree is simple. A sample implementaion on an Integer as key and String as value is privided as a template. Following is a snippet implementation:_\r\n\r\n\tpublic class IntStringBinaryTree extends BinaryTree<Integer, String> {\r\n\r\n\t\tpublic IntStringBinaryTree(boolean debug) {\r\n\t\t\tsuper(debug);\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic int compare(Node<Integer, String> a, Node<Integer, String> b) {\r\n\t\t\tif ( a.key.intValue() < b.key.intValue() ) {\r\n\t\t\t\treturn -1;\r\n\t\t\t} else if ( a.key.intValue() == b.key.intValue() ){\r\n\t\t\t\treturn 0;\r\n\t\t\t} else {\r\n\t\t\t\treturn 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t@Override\r\n\t\tpublic void orderedNode(Node<Integer, String> orderedNode) {\r\n\t\t\tInteger key = orderedNode.key;\r\n\t\t\tSystem.out.println(\"ordered node key: \" + key.intValue());\r\n\t\t}\r\n\t\r\n\t}\r\n\r\nThis is all it takes to create a Binary Search Tree implementiation of Integer as key, and String as value. A sample usage of a class implementing 100 random numbers in the binary tree, find a record, and remove a record is:\r\n\r\n\timport java.util.Random;\r\n\t\r\n\timport com.mmontuori.binarytree.*;\r\n\t\r\n\tpublic class TestBinTree {\r\n\t\r\n\t\tprivate static final int SIZE = 100;\r\n\t\t\r\n\t\tpublic static void main(String[] args) {\r\n\t\t\tBinaryTree<Integer, String> testTree = new IntStringBinaryTree();\r\n\t\t\tRandom random = new Random();\r\n\t\t\tint toSearch = 0;\r\n\t\t\tfor ( int i=0; i<SIZE; ++i) {\r\n\t\t\t\tint rnd = random.nextInt(10000);\r\n\t\t\t\tInteger key = new Integer(rnd);\r\n\t\t\t\tString value = String.valueOf(rnd);\r\n\t\t\t\tNode<Integer, String> node = new Node<Integer,String>(key, value);\r\n\t\t\t\tSystem.out.println(\"adding node: \" + rnd);\r\n\t\t\t\ttestTree.addNode(node);\r\n\t\t\t\tif ( SIZE/2 == i ) {\r\n\t\t\t\t\ttoSearch = rnd;\r\n\t\t\t\t\tSystem.out.println(\"record to search and remove: \" + toSearch);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tSystem.out.println(\"tree size: \" + testTree.getSize());\r\n\t\t\tSystem.out.println(\"tree right size: \" + testTree.getRightSize());\r\n\t\t\tSystem.out.println(\"tree left size: \" + testTree.getLeftSize());\r\n\t\t\ttestTree.traverseInOrder(testTree.getRoot());\r\n\t\t\tInteger key = new Integer(toSearch);\r\n\t\t\tNode<Integer,String> node = testTree.findNode(key);\r\n\t\t\tSystem.out.println(\"node found: \" + node.key.intValue());\r\n\t\t\ttestTree.removeNode(toSearch);\r\n\t\t\ttestTree.traverseInOrder(testTree.getRoot());\r\n\t\t\tSystem.out.println(\"tree size: \" + testTree.getSize());\r\n\t\t\tSystem.out.println(\"tree right size: \" + testTree.getRightSize());\r\n\t\t\tSystem.out.println(\"tree left size: \" + testTree.getLeftSize());\r\n\t\t}\r\n\r\n\t}\r\n\r\n## Deploying\r\n\r\n_Just add jbinarytree.jar to your CLASSPATH and use it._\r\n\r\n## License\r\nJBinaryTree is release under the GPLv2 license.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}